## 题目

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 

 说明： 

 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 

 示例 1: 

 输入: [2,2,1]
输出: 1
 

 示例 2: 

 输入: [4,1,2,1,2]
 输出: 4 
 
## 解题思路

本题可以用hash表来解决，但用位运算的话更加的简单，且不占用额外的内存空间。

在此之前 需要先了解java的位运算
 
符号 | 描述 | 运算规则
--- | --- | ---
`&` | 按位与 | 两位都为1时，结果才为1
`|` | 按位或 | 只要有一位为1，结果就为1
`^` | 异或 | 两位不同是结果为1，否则为0
`~` | 取反 | 单目操作符，0变1 1变0
`>>` | 带符号位右移 | 带符号位右移 相当于除以2，对于正数来说和 `>>>` 是一样的
`>>>` | 不带符号位右移 |  右移时高位补0
`<<` | 左移 | 相当于乘 2

并且非常重要的是，**这些位运算满足 交换律 结合律 分配率**

好了，下面我们再来看这道题

显而易见，可以采用异或运算来解决。

对于异或运算来说，相同的两个数字在异或运算后会等于0。并且满足结合律

由此可见，对于本题来说，只要数组每个数字都依次进行异或运算，最后剩下的数字必然是只出现一次的

```java
class Solution {
    public int singleNumber(int[] nums) {
        int length = nums.length;
        int result = 0;
        for (int i = 0; i<length; i++) {
            result ^= nums[i];
        }
        return result;
    }
}
```